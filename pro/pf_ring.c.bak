/*
 *  Copyright (C) 2007 Luca Deri <deri@ntop.org>
 *
 *  		       http://www.ntop.org/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#ifdef HAVE_PF_RING

/* ****************************************************** */

void* fetchPfRingPackets(void* notUsed) {
  struct pfring_pkthdr hdr;
  char packet[LONG_SNAPLEN];
  int rc, i, use_full_packet = 1 /* FIX */;
  struct pcap_pkthdr h;
  struct ether_header ehdr;
  static u_char msg_shown = 0;
  u_int packetToGo = 0;

  memset(&ehdr, 0, sizeof(ehdr));

  /* FIX FIX FIX FIX FIX FIX - setup sampling rate wih PF_RING... */

  /*
    Check if we can just use PF_RING in-kernel packet parsing or
    if we need full packet parsing
  */
  for(i=0; i<TEMPLATE_LIST_LEN; i++) {
    if(readOnlyGlobals.v9TemplateElementList[i] != NULL) {
      V9V10TemplateElementId *el = readOnlyGlobals.v9TemplateElementList[i];

      switch(el->templateElementId) {
      case 27: /* IPV6_SRC_ADDR */
      case 28: /* IPV6_DST_ADDR */
      case 29: /* IPV6_SRC_MASK */
      case 30: /* IPV6_DST_MASK */
      case 32: /* ICMP_TYPE */
      case 56: /* IN_SRC_MAC */
      case 57: /* OUT_DST_MAC */
      case 70: /* MPLS_LABEL_1 */
      case 71: /* MPLS_LABEL_2 */
      case 72: /* MPLS_LABEL_3 */
      case 73: /* MPLS_LABEL_4 */
      case 74: /* MPLS_LABEL_5 */
      case 75: /* MPLS_LABEL_6 */
      case 76: /* MPLS_LABEL_7 */
      case 77: /* MPLS_LABEL_8 */
      case 78: /* MPLS_LABEL_9 */
      case 79: /* MPLS_LABEL_10 */
      case 90: /* FRAGMENTED */
      case 96: /* IN_PAYLOAD */
      case 97: /* OUT_PAYLOAD */
      case 98: /* ICMP_FLAGS */
	use_full_packet = 1;
	break;
      }

      if(el->templateElementId > 99) use_full_packet = 1;
    } else
      break;

    if(use_full_packet) break;
  }

  packetToGo = readOnlyGlobals.pktSampleRate;

  while(!readWriteGlobals->shutdownInProgress) {
    rc = pfring_recv(readWriteGlobals->ring, packet, sizeof(packet), &hdr, 1 /* wait_for_incoming_packet */);

    /* traceEvent(TRACE_NORMAL, "packetToGo = %d", packetToGo); */

    if(packetToGo <= 1) {
      /* traceEvent(TRACE_NORMAL, "Processing packet"); */

      if(rc > 0) {
	if(!use_full_packet) {
	  IpAddress src, dst;
	  struct in_addr addr;
	  int payload_offset = hdr.parsed_pkt.pkt_detail.offset.eth_offset
	    +hdr.parsed_pkt.pkt_detail.offset.payload_offset;
	  int payload_len = (payload_offset > hdr.len) ? 0 : hdr.len - payload_offset;
	  if(!msg_shown) {
	    traceEvent(TRACE_NORMAL, "Using PF_RING in-kernel accelerated packet parsing");
	    msg_shown = 1;
	  }

	  if(hdr.parsed_pkt.eth_type == 0x0800 /* IPv4 */) {
	    h.len = hdr.len, h.caplen = hdr.caplen;
	    h.ts.tv_sec = hdr.ts.tv_sec, h.ts.tv_usec = hdr.ts.tv_usec;

	    src.ipVersion = 4, dst.ipVersion = 4;

	    addr.s_addr = hdr.parsed_pkt.ipv4_src;
	    if(readOnlyGlobals.ignoreIP || (!isLocalAddress(&addr)))
	      src.ipType.ipv4 = 0; /* 0.0.0.0 */
	    else
	      src.ipType.ipv4 = addr.s_addr;

	    addr.s_addr = hdr.parsed_pkt.ipv4_dst;
	    if(readOnlyGlobals.ignoreIP || (!isLocalAddress(&addr)))
	      dst.ipType.ipv4 = 0; /* 0.0.0.0 */
	    else
	      dst.ipType.ipv4 = addr.s_addr;

	    addPktToHash(hdr.parsed_pkt.l3_proto, 0, 1, hdr.parsed_pkt.ipv4_tos,
			 (hdr.parsed_pkt.vlan_id != (u_int16_t)-1) ? hdr.parsed_pkt.vlan_id : 0, 0,
			 &ehdr,
			 src, hdr.parsed_pkt.l4_src_port,
			 dst, hdr.parsed_pkt.l4_dst_port,
			 hdr.len, hdr.parsed_pkt.tcp_flags, 0, 0,
			 0, NULL,
			 NO_INTERFACE_INDEX, NO_INTERFACE_INDEX, /* Will be computed later on */
			 NULL,
			 &h, (u_char*)packet,
			 payload_offset, payload_len, 0,
			 0, 0, 0, 0, 0 /* flow_sender_ip */);
	  }
	} else {
	  if(!msg_shown) {
	    traceEvent(TRACE_NORMAL, "Using PF_RING application packet parsing");
	    msg_shown = 1;
	  }

	  h.len = hdr.len, h.caplen = hdr.caplen;
	  h.ts.tv_sec = hdr.ts.tv_sec, h.ts.tv_usec = hdr.ts.tv_usec;

	  decodePacket(&h, (u_char*)packet, NO_INTERFACE_INDEX, NO_INTERFACE_INDEX,
		       0 /* flow_sender_ip */);
	}
      }

      if(readOnlyGlobals.pktSampleRate > 0)
	packetToGo = readOnlyGlobals.pktSampleRate;
    } else
      packetToGo--;
  }

  return(NULL);
}

/* ********************************************* */

pfring* open_ring(char *dev, u_char *open_device) {
  pfring* the_ring = NULL;

  if((the_ring = pfring_open(dev,
			     readOnlyGlobals.promisc_mode /* promiscuous */,
			     DEFAULT_SNAPLEN, /* LONG_SNAPLEN */
			     1 /* reentrant */)) != NULL) {
    u_int32_t version;
    int rc;

    rc = pfring_version(the_ring, &version);

    if((rc == -1) || (version < 0x030502)) {
      traceEvent(TRACE_WARNING, "nProbe requires PF_RING v.3.9.3 or above (you have v.%d.%d.%d)",
		 (version & 0xFFFF0000) >> 16,
		 (version & 0x0000FF00) >> 8,
		 version & 0x000000FF);
      pfring_close(the_ring);
      the_ring = NULL;
    } else {
      traceEvent(TRACE_INFO, "Successfully open PF_RING v.%d.%d.%d on device %s\n",
		 (version & 0xFFFF0000) >> 16,
		 (version & 0x0000FF00) >> 8,
		 (version & 0x000000FF),
		 readOnlyGlobals.tmpDev);
      *open_device = 0;
      readOnlyGlobals.datalink = DLT_EN10MB;
      pfring_set_application_name(the_ring, "nProbe");
    }
  }

  
  return(the_ring);
}

#endif /* HAVE_PF_RING */
